#+title: Goal-oriented Coding
#+date: 2023-01-04
#+author: Tze-Yang Tung
#+columns: %custom_id %item
#+startup: latexpreview

#+hugo_base_dir: ../
#+hugo_section: projects

#+hugo_weight: 2001
#+hugo_auto_set_lastmod: t

#+hugo_tags: Projects
#+hugo_draft: false
* Project goal
:PROPERTIES:
:CUSTOM_ID: universal_coding_a
:END:
This project aims to leverage [[file:information_theory.org::#information_theory_d2][universal quantisation]] for goal-oriented coding.
It is closely related to the [[file:information_theory.org::#information_theory_b][rate-distortion-perception]], as it was shown that under perfect perceptual constraint, a stochastic encoder/decoder can improve the distortion.
* Applications
:PROPERTIES:
:CUSTOM_ID: universal_coding_b
:END:
A potential application for [[file:information_theory.org::#information_theory_d2][universal quantisation]] in compression is in diffusion models.
Diffusion models essentially compute the VAE objective for every time step (usually using randomly chosen time step) to guide the decoder from isotropic noise to an image sample.
Although compression using diffusion models has been [[https://arxiv.org/abs/2209.06950][demonstrated already]], their approach relies on a latent variable with which the decoder is conditioned on, in order to guide decoder.
However, this is a tall ask for a single, one step, latent variable.
Typically, diffusion models will condition on all of the latents in each step, whereas here they are only conditioning on a single variable generated in one step.
This single variable is then quantised and coded as many prior compression works have used, e.g., uniform noise to approximate rounding error and a hyperprior density estimation.

A better approach would be to transmit those latent vectors in each step using universal quantisation.
Starting from the highest step, where the posterior is almost an isotropic Gaussian distribution, we send a sample from this distribution using universal quantisation and the decoder tries to approximate likelihood function.
\( \forall t, x_{t-1} \Rightarrow q(x_t | x_{t-1}) \stackrel{x_t}{\Rightarrow} p(x_{t-1} | x_t) \Rightarrow \hat{x}_{t-1} \), compute VAE loss \( l_{ELBO}(x_{t-1}, \hat{x}_{t-1}) \).
Moreover, the coding rate should be approximately constant since at each step \( q(x_t | x_{t-1}) \approx p(x_{t-1} | x_t) \), therefore the KL divergence should be small.
Essentially, the cost of coding is amortised into the diffusion steps.
Even though this doesn't make the coding speed any faster, it does provide a way to make rate-distortion trade-offs since we can stop coding after a certain point and obtain the intermediate image.

Another application is to consider a stochastic process which is conditional on a common random variable and the encoder wishes to communicate a sample of the stochastic process to a decoder.
This could be an interesting [[file:semantic_communications.org::#semantic_communications_c][goal-oriented communication problem]].

Another interesting possibility is that because both the sender and the receiver are required to have a common random source, could the seed be used as a secret key for symmetric encryption?
Basically, without the common random source, is it possible to decode successfully, even if approximately?
(might be hard to prove the security of the scheme although maybe some kind of privacy guarantees can be made)

Another possibility is [[file:information_theory.org::#information_theory_e1][*posterior matching*]].
Interestingly, there are some similarities between posterior matching and [[file:information_theory.org::#information_theory_d2][universal quantisation]].
In posterior matching, the next transmitted random variable \( X_{n+1} \) is independent of the previous received values \( Y^n \), to ensure that it represents new information.
Moreover, the message \( \theta \) can be almost surely uniquely recovered from \( (X_{n+1}, Y^n) \) as \( n \rightarrow \infty \).
An important theorem that [[file:information_theory.org::#information_theory_d2][universal quantisation]] relies on is the strong functional representation [[http://dx.doi.org/10.1109/TIT.2018.2865570][(SFR)]] lemma, which states that for general \( (X, Y) \), there exists a \( Z \) that is independent of \( X \) and \( Y \), and is a function of \( (X, Z) \), such that \( H(Y | Z) \leq I(X; Y) + \log(I(X; Y) + 1) + 4 \).
Therefore, if we map \( Z \) to \( X_{n+1} \) in the previous problem and \( Y \mapsto \theta \), \( X \mapsto Y^n \), then we have \( H(\theta | X_{n+1}) \leq I(Y^n; \theta) + \log(I(Y^n; \theta) + 1) + 4 \).
We can interpret \( H(\theta | X_{n+1}) \) as any further uncertainty about the message after transmitting \( X_{n+1} \) and \( I(Y^n; \theta) \) as knowledge the receiver has gained already.

We can apply [[file:information_theory.org::#information_theory_d2][universal quantisation]] to the transmission of a stochastic policy to a remote agent for [[file:reinforcement_learning.org::#reinforcement_learning_a][MDPs]] or [[file:reinforcement_learning.org::#reinforcement_learning_b][POMDPs]].
That is, consider a controller which has policy \( \pi(a | s) \), and wishes to transmit a random action \( a \sim \pi(a | s) \) to a remote agent to carry out.
It is trivial to see that this corresponds exactly to the SFR lemma, where \( Y \mapsto a \) and \( X \mapsto s \).
It corresponds to the "sending actions" policy we have considered in the past.
A few scenarios to consider:
+ If we have an exact channel model \( P(\hat{a} | a) \), is there a JSCC equivalent of this?
+ What if we have noiseless feedback of \( \hat{a} \)?
+ What if the controller also needs to learn the optimal policy?
  In this case, it is possible that initially, we would communicate very little so that the remote agent simply takes random actions based on a prior distribution.
  As the controller learns based on the reward feedback of the agent's actions, it then begins to communicate what it thinks is optimal. This can be done using the common randomness (prior).
  The agent can construct an empirical distribution of the policy over time and once it has a sufficiently good estimate, no more communication is required.
  In this [[http://dx.doi.org/10.1109/ISIT50566.2022.9834399][paper]], a similar problem considering contexual multi-armed bandits (CMAB) was solved.
+ If we have a MA-POMDP, the problem can be seen as matching the joint distribution of the agents' actions with the optimal policy over all the agents.
  [[file:information_theory.org::#information_theory_b1][Common randomness]] could also be useful in this case to reduce the communication load and could perhaps even be done with simply a [[http://dx.doi.org/10.1109/GLOBECOM42002.2020.9322460][correlated random variable]].
+ What if the action space is *continuous*? Universal quantisation could be used to quantise this to a finite rate? Can this be applied to a *goal-oriented quantisation* problem?
  This might be used in a sensor network.
* MA-POMDP Problem
:PROPERTIES:
:CUSTOM_ID: universal_coding_c
:END:
Consider a 2-agent [[file:reinforcement_learning.org::#reinforcement_learning_b][POMDP]], where the environment is governed by the transition kernel \( P(s_1^t, s_2^t | a_1^{t-1}, a_2^{t-1}) \) and the agents have policies \( \pi_i^t(a_i^t | s_i^t, m_i^t)\; i \in \{0, 1\} \).
Let's assume that the union of the observations is in the state \( s_1 \cup s_2 \in \mathcal{S} \).
The messages \( m_i^t \) are generated by the other agent and sent to the opposite agent.
We want to determine the minimum rate of the messages such that the agents converge to the optimal policy \( \pi^\ast(a_1^t, a_2^t | s_1^t, s_2^t) \).
** Initial thoughts
:PROPERTIES:
:CUSTOM_ID: universal_coding_c1
:END:
It is valid to first consider what are the missing information for each agent to obtain stationarity.
For each agent, they need to be able to know the policy and observation of the other agent in order to have the complete information necessary to observe a stationary POMDP.
From the perspective of agent 1, if we know the transition kernel \( P(s_1^t, s_2^t | a_1^{t-1}, a_2^{t-1}) \), then if we know the action taken by agent 2, we can code the observation of agent 2 using \( P(s_2^t | a_1^{t-1}, a_2^{t-1}) \) by marginalising over \( s_1^t \).
In order to send the action, if we are given common randomness, then we can initialise both policies using the same random variable so that at \( t = 1 \), each agent simply codes the action taken based on \( \pi_i^1(a_i^1) \).
For \( t > 1 \), instead of coding the action based on \( \pi_i^t(a_i^t | s_i^t) \), we can use relative entropy coding to send a sample \( a_i^t \sim \pi_i^t(a_i^t | s_i^t) \) using \( 2^\epsilon \) samples and \( \epsilon \) bits, where \( \epsilon = D_{KL}(\pi_i^t || \pi_i^{t-1}) \).
Moreover, if we use a update policy like trust region policy optimisation (TRPO), then it is guaranteed that \( D_{KL}(\pi_i^t || \pi_i^{t-1}) \leq \epsilon \).
Knowing the action and the observation of the other agent, the agent can update its belief of the other agent's policy exactly the same as the other agent.
Since the belief matches the policy exactly, \( \pi_i^t \) becomes the new common randomness.
Therefore, in each round, the agents only need to send the amount of update that their policies changed by.
In fact, if we use something similar to epsilon greedy for exploration, then the prior chosen at the beginning would represent the exploration distribution and while epsilon is large at the beginning, fewer communication would be needed, and as epsilon gets smaller we would communicate more.

The thing that needs to be checked is whether or not no common randomness can achieve the same thing.
If no common prior on the policy is given at \( t = 1 \), then each agent can only form a belief that may not be the same as the policy of the other agent (private randomness).
Therefore, to send the action, the agent must use at least \( H(a_i^t | s_i^t) \) bits, based on the current policy \( \pi_i^t \).
This can be significantly bigger than \( \epsilon \).
The difference would be even greater if the action space was continuous since the private randomness version would need to quantize, leading to loss in performance.

This project also merges well with deep RL since the agent policies can be parameterized by DNNs.
